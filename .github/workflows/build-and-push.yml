name: Docker Build & Push to ECR

on:
  workflow_call:
    inputs:
      service-name:
        required: true
        type: string
      build-context:
        required: true
        type: string
      env:
        required: false
        type: string
        description: "Environment name (e.g., dev/staging/prod)"
        default: "dev"
      image-tag:
        required: false
        type: string
        description: "Docker image tag (e.g., Git tag or SHA)"
        default: "latest"
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
    outputs:
      image-tag:
        description: "The image tag used (built or reused)"
        value: ${{ jobs.build-and-push.outputs.image-tag }}
      image-uri:
        description: "Full ECR image URI"
        value: ${{ jobs.build-and-push.outputs.image-uri }}
      built:
        description: "true if we built/pushed; false if we reused existing"
        value: ${{ jobs.build-and-push.outputs.built }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.export.outputs.tag }}
      image-uri: ${{ steps.export.outputs.uri }}
      built:     ${{ steps.export.outputs.built }}
    steps:
      # --- AWS first so we can check ECR before any heavy work ---
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-2

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ---- EARLY EXIT if image tag already in ECR (except for mutable tags) ----
      - name: Check if image:tag exists in ECR
        id: check
        env:
          REPOSITORY: ${{ inputs.service-name }}-${{ inputs.env }}
          TAG:        ${{ inputs.image-tag }}
        run: |
          set -euo pipefail
          # Treat these tags as mutable â†’ always rebuild
          case "$TAG" in
            latest|dev|main) echo "exists=false" >> "$GITHUB_OUTPUT"; exit 0 ;;
          esac

          if aws ecr describe-images \
              --repository-name "$REPOSITORY" \
              --image-ids imageTag="$TAG" \
              --region us-east-2 >/dev/null 2>&1; then
            echo "exists=true"  >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      # Export common outputs now (built=false by default, overridden later if we build)
      - name: Export outputs (pre)
        id: export
        env:
          REGISTRY:   ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: ${{ inputs.service-name }}-${{ inputs.env }}
          TAG:        ${{ inputs.image-tag }}
          EXISTS:     ${{ steps.check.outputs.exists }}
        run: |
          set -euo pipefail
          URI="${REGISTRY}/${REPOSITORY}:${TAG}"
          echo "tag=${TAG}"   >> "$GITHUB_OUTPUT"
          echo "uri=${URI}"   >> "$GITHUB_OUTPUT"
          if [ "${EXISTS:-false}" = "true" ]; then
            echo "built=false" >> "$GITHUB_OUTPUT"
            echo "âœ… Image already exists in ECR: ${URI} â€” skipping build & push."
          else
            echo "built=pending" >> "$GITHUB_OUTPUT"
          fi

      # ---- Only do the heavy work if we need to build ----
      - name: Checkout Caller Code
        if: ${{ steps.check.outputs.exists != 'true' }}
        uses: actions/checkout@v4
        with:
          path: caller-repo

      - name: Checkout Central Dockerfiles
        if: ${{ steps.check.outputs.exists != 'true' }}
        uses: actions/checkout@v4
        with:
          repository: Parspec/parspec-ai-ci-common
          path: ci-cd-workflows-repo

      - name: Install jq
        if: ${{ steps.check.outputs.exists != 'true' }}
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Fetch Service Environment Variables from Secrets Manager
        if: ${{ steps.check.outputs.exists != 'true' }}
        id: get-env-vars
        run: |
          SECRET_NAME="${{ inputs.service-name }}-${{ inputs.env }}"
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$SECRET_NAME" \
            --query SecretString \
            --output text \
            --region us-east-2 || echo "")
          if [ -z "$SECRET_JSON" ]; then
            echo "::notice title=Secrets::No secret found for $SECRET_NAME"
            echo "BUILD_ARGS_STRING=" >> $GITHUB_ENV
          else
            BUILD_ARGS_STRING=$(echo "$SECRET_JSON" | jq -r 'to_entries[] | "--build-arg \(.key)=\(.value)"' | tr '\n' ' ')
            echo "BUILD_ARGS_STRING=$BUILD_ARGS_STRING" >> $GITHUB_ENV
          fi

      - name: Copy shared package to service directory
        if: ${{ steps.check.outputs.exists != 'true' }}
        run: |
          cp -r ./caller-repo/shared ./caller-repo/${{ inputs.build-context }}/ || true
          echo "âœ… Shared package copied (or not present)."

      - name: Compute APP_MODULE from service-name
        if: ${{ steps.check.outputs.exists != 'true' }}
        id: appmod
        run: |
          # Derive fastapi_<service>:app from service-name (e.g., table-parsing-service -> fastapi_table_parsing:app)
          SERVICE_NAME_UNDERSCORE="$(echo '${{ inputs.service-name }}' | sed 's/-/_/g; s/_service$//')"
          APP_MODULE="fastapi_${SERVICE_NAME_UNDERSCORE}:app"

          # Optional: fallback to src.main:app if present in the service (more robust)
          if [ -f "./caller-repo/${{ inputs.build-context }}/src/main.py" ]; then
            APP_MODULE="src.main:app"
          fi

          echo "Computed APP_MODULE=$APP_MODULE"
          echo "APP_MODULE=$APP_MODULE" >> $GITHUB_ENV
          echo "app_module=$APP_MODULE" >> $GITHUB_OUTPUT
      - name: Build, Tag, and Push Docker Image

        if: ${{ steps.check.outputs.exists != 'true' }}
        env:
          ECR_REGISTRY:        ${{ steps.login-ecr.outputs.registry }}
          FULL_ECR_REPOSITORY: ${{ inputs.service-name }}-${{ inputs.env }}
          IMAGE_TAG:           ${{ inputs.image-tag }}
          
        run: |
          echo "ðŸ”¨ Building $ECR_REGISTRY/$FULL_ECR_REPOSITORY:$IMAGE_TAG"
          docker build \
            -t $ECR_REGISTRY/$FULL_ECR_REPOSITORY:$IMAGE_TAG \
            -f ./ci-cd-workflows-repo/docker-templates/Dockerfile \
            ${BUILD_ARGS_STRING} \
            --build-arg APP_MODULE=$APP_MODULE \
            ./caller-repo/${{ inputs.build-context }}
          echo "ðŸš€ Pushing..."
          docker push $ECR_REGISTRY/$FULL_ECR_REPOSITORY:$IMAGE_TAG

      - name: Mark built=true
        if: ${{ steps.check.outputs.exists != 'true' }}
        run: echo "built=true" >> "$GITHUB_OUTPUT"
        id: markbuilt